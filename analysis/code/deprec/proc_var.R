# Extension to bootstrap from the generalized impulse response function

fevd_generalised <- function(model, n.ahead=10, normalize=TRUE) {
if (class(model) != "varest") {
return("The model class is not varest!")
}
A <- Phi(model, n.ahead)
epsilon <- residuals(model)
Sigma <- t(epsilon)%*%epsilon / (model$obs - model$p*model$K)
gi <- array(0, dim(A))
sigmas <- sqrt(diag(Sigma))
for (j in 1:dim(A)[3]) {
gi[,,j] <- t( t( A[,,j]%*%Sigma ) / sqrt(sigmas) )
}
d <- array(0, dim(A)[c(2,3)])
for (j in 1:dim(d)[2]) {
d[,j] <- diag(A[,,j]%*%Sigma%*%t(A[,,j]))
}

num <- apply(gi^2,1:2,sum)
den <- c(apply(d,1,sum))
fevd <- num/den
if (normalize) {
return(fevd/apply(fevd, 1, sum))
} else {
return(fevd)
}
}




irf_generalised <- function(model, n.ahead = 10) {
	if (class(model) != "varest") {
	return("The model class is not varest!")
	}
	A <- Phi(model, n.ahead)
	epsilon <- residuals(model)
	Sigma <- t(epsilon)%*%epsilon / (model$obs - model$p*model$K)
	gi <- array(0, dim(A))
	sigmas <- sqrt(diag(Sigma))
	for (j in 1:dim(A)[3]) {
	gi[,,j] <- t( t( A[,,j]%*%Sigma ) / sigmas )
	}
	return(gi)
}



irf2 <- function (x, impulse = NULL, response = NULL, n.ahead = 10, ortho = TRUE, 
    cumulative = FALSE, boot = TRUE, ci = 0.95, runs = 100, seed = NULL, 
    ...) 
{
    if (!(class(x) == "varest")) {
        stop("\nPlease provide an object of class 'varest', generated by 'VAR()'.\n")
    }
    y.names <- colnames(x$y)
    if (is.null(impulse)) {
        impulse <- y.names
    }
    else {
        impulse <- as.vector(as.character(impulse))
        if (any(!(impulse %in% y.names))) {
            stop("\nPlease provide variables names in impulse\nthat are in the set of endogenous variables.\n")
        }
        impulse <- subset(y.names, subset = y.names %in% impulse)
    }
    if (is.null(response)) {
        response <- y.names
    }
    else {
        response <- as.vector(as.character(response))
        if (any(!(response %in% y.names))) {
            stop("\nPlease provide variables names in response\nthat are in the set of endogenous variables.\n")
        }
        response <- subset(y.names, subset = y.names %in% response)
    }
	
	
    irs <- .irf(x = x, impulse = impulse, response = response, 
        y.names = y.names, n.ahead = n.ahead, ortho = ortho, 
        cumulative = cumulative)
		
		
		
    Lower <- NULL
    Upper <- NULL
    if (boot) {
        ci <- as.numeric(ci)
        if ((ci <= 0) | (ci >= 1)) {
            stop("\nPlease provide a number between 0 and 1 for the confidence interval.\n")
        }
        ci <- 1 - ci
		
        BOOT <- .boot(x = x, n.ahead = n.ahead, runs = runs, 
            ortho = ortho, cumulative = cumulative, impulse = impulse, 
            response = response, ci = ci, seed = seed, y.names = y.names)
        
		Lower <- BOOT$Lower
        Upper <- BOOT$Upper
    }
    result <- list(irf = irs, Lower = Lower, Upper = Upper, response = response, 
        impulse = impulse, ortho = ortho, cumulative = cumulative, 
        runs = runs, ci = ci, boot = boot, model = class(x))
    class(result) <- "varirf"
    return(result)
}



.boot2 <- function(x, n.ahead, runs, ortho, cumulative, impulse, response, 
    ci, seed, y.names) 
{
    if (!(is.null(seed))) 
        set.seed(abs(as.integer(seed)))
    if (class(x) == "varest") {
        VAR <- eval.parent(x)
    }
    else if (class(x) == "svarest") {
        VAR <- eval.parent(x$var)
    }
    else {
        stop("Bootstrap not implemented for this class.\n")
    }
	
	
    p <- VAR$p
    K <- VAR$K
    obs <- VAR$obs
    total <- VAR$totobs
    type <- VAR$type
    B <- Bcoef(VAR)
	
	
    BOOT <- vector("list", runs)
    ysampled <- matrix(0, nrow = total, ncol = K)
    colnames(ysampled) <- colnames(VAR$y)
	
	
    Zdet <- NULL
    if (ncol(VAR$datamat) > (K * (p + 1))) {
        Zdet <- as.matrix(VAR$datamat[, (K * (p + 1) + 1):ncol(VAR$datamat)])
    }
	
	
    resorig <- scale(resid(VAR), scale = FALSE)
	
    B <- Bcoef(VAR)
	
    for (i in 1:runs) {
        booted <- sample(c(1:obs), replace = TRUE)
        resid <- resorig[booted, ]
        lasty <- c(t(VAR$y[p:1, ]))
		
        ysampled[c(1:p), ] <- VAR$y[c(1:p), ]
        for (j in 1:obs) {
            lasty <- lasty[1:(K * p)]
            Z <- c(lasty, Zdet[j, ])
            ysampled[j + p, ] <- B %*% Z + resid[j, ]
            lasty <- c(ysampled[j + p, ], lasty)
        }
		
        varboot <- update(VAR, y = ysampled)
        if (class(x) == "svarest") {
            varboot <- update(x, x = varboot)
        }
		
        BOOT[[i]] <- .irf(x = varboot, n.ahead = n.ahead, ortho = ortho, 
            cumulative = cumulative, impulse = impulse, response = response, 
            y.names = y.names)
    }
	
    lower <- ci/2
    upper <- 1 - ci/2
	
    mat.l <- matrix(NA, nrow = n.ahead + 1, ncol = length(response))
    mat.u <- matrix(NA, nrow = n.ahead + 1, ncol = length(response))
	
    Lower <- list()
    Upper <- list()
    idx1 <- length(impulse)
    idx2 <- length(response)
    idx3 <- n.ahead + 1
	
    temp <- rep(NA, runs)
    for (j in 1:idx1) {
        for (m in 1:idx2) {
            for (l in 1:idx3) {
                for (i in 1:runs) {
                  if (idx2 > 1) {
                    temp[i] <- BOOT[[i]][[j]][l, m]
                  }
                  else {
                    temp[i] <- matrix(BOOT[[i]][[j]])[l, m]
                  }
                }
                mat.l[l, m] <- quantile(temp, lower, na.rm = TRUE)
                mat.u[l, m] <- quantile(temp, upper, na.rm = TRUE)
            }
        }
        colnames(mat.l) <- response
        colnames(mat.u) <- response
        Lower[[j]] <- mat.l
        Upper[[j]] <- mat.u
    }
	
    names(Lower) <- impulse
    names(Upper) <- impulse
    result <- list(Lower = Lower, Upper = Upper)
    return(result)
}

